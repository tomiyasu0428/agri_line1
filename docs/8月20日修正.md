「ここをゼロ」のロジックが間違っています 🔴

現在のコードの問題
javascriptdocument.getElementById('zeroNow').addEventListener('click', ()=>{
  // 現在の実装
  const perp = ct?ct.perp:0;
  const deltaIndex = Math.round(perp/swathWidth);
  currentLineIndex += deltaIndex;  // ← これが問題！
});
何が起きているか：

横ズレ 4.0m、作業幅 2.0m の場合
deltaIndex = round(4.0/2.0) = 2
currentLineIndex = -1 + 2 = 1本目
結果：1本目 × 2.0m - 4.0m = -2.0m（ゼロにならない！）

正しい実装方法
方法1: 単純にインデックスを計算し直す（推奨）
javascriptdocument.getElementById('zeroNow').addEventListener('click', ()=>{
  if(!last||!A||!B){ 
    alert('A/B設定と位置取得後に押してください'); 
    return; 
  }
  
  const xy = degToMeters(last.lat, last.lon, A.lat0, A.lon0);
  const ct = crossTrack(xy);
  const perp = ct ? ct.perp : 0;
  
  // 現在位置がゼロになるようにインデックスを設定
  currentLineIndex = Math.round(perp / swathWidth);
  
  // 確認用
  const newOffset = (currentLineIndex * swathWidth) - perp;
  console.log('新しいオフセット:', newOffset); // ≈ 0.0 になるはず
  
  updateUI(0, vecLen(xy), vecLen({x:B.xy.x-A.xy.x,y:B.xy.y-A.xy.y}));
  drawViz(0);
  el.hint.textContent = 'ここをゼロを適用しました';
});
方法2: オフセット値を保持する方式
javascriptlet zeroOffset = 0;  // グローバル変数を追加

document.getElementById('zeroNow').addEventListener('click', ()=>{
  const xy = degToMeters(last.lat, last.lon, A.lat0, A.lon0);
  const ct = crossTrack(xy);
  const perp = ct ? ct.perp : 0;
  
  // 現在の横ズレを記憶
  zeroOffset = (currentLineIndex * swathWidth) - perp;
  
  // 横ズレ計算時に適用
  const offset = (currentLineIndex * swathWidth) - perp - zeroOffset;
});
なぜ現在のコードが間違っているか
現在のコード：
deltaIndex = round(perp/swathWidth) を「足している」
正しくは：
currentLineIndex = round(perp/swathWidth) に「置き換える」
具体例で検証
ケース1: 左に4.0mずれている場合
現在位置の横ズレ: -4.0m（左）
作業幅: 2.0m
現在のライン: -1本目

正しい計算:
currentLineIndex = round(-4.0/2.0) = -2
結果: -2 × 2.0 - (-4.0) = 0.0m ✅
ケース2: 右に17.3mずれている場合
現在位置の横ズレ: 17.3m（右）
作業幅: 2.0m（推定）
現在のライン: 16本目

正しい計算:
currentLineIndex = round(17.3/2.0) = 9
結果: 9 × 2.0 - 17.3 = 0.7m（ほぼゼロ）✅
修正版コード（完全版）
javascriptdocument.getElementById('zeroNow').addEventListener('click', ()=>{
  if(!last||!A||!B){ 
    alert('A/B設定と位置取得後に押してください'); 
    return; 
  }
  
  const abDist = vecLen({x:B.xy.x-A.xy.x,y:B.xy.y-A.xy.y});
  if(abDist<5){ 
    alert('AB距離が短すぎます（5m以上に）'); 
    return; 
  }
  
  const xy = degToMeters(last.lat, last.lon, A.lat0, A.lon0);
  const ct = crossTrack(xy);
  const perp = ct ? ct.perp : 0;
  
  // += ではなく = で置き換える
  currentLineIndex = Math.round(perp / swathWidth);
  
  // 保存
  localStorage.setItem('lineIndex', String(currentLineIndex));
  
  // UI更新（オフセットは0になる）
  updateUI(0, vecLen(xy), abDist);
  drawViz(0);
  el.hint.textContent = '✅ ここをゼロに設定しました';
});
これで「ここをゼロ」を押すと確実に 0.0m になるはずです！再試行HT右にハンドルを切って、みぎにいくと画面では左に行きます。コードの問題？編集左右が逆になっている問題を発見！ 🔄
問題の原因
コードの横ズレ計算で符号が逆になっています：
javascriptfunction crossTrack(p){
  // ...
  const perp = w.x*(-n.y) + w.y*(n.x);  // ← ここの計算
  return {perp}
}

// 表示部分
el.dir.textContent = offset>0 ? '← 左へ' : (offset<0 ? '右へ →' : '—');
何が起きているか
実際の動き：右に移動（13.6m）
内部計算：perp = -13.6（負の値）
表示計算：offset = 0 - (-13.6) = +13.6
画面表示：「← 左へ 13.6m」（逆！）
修正方法
方法1: 符号を反転（簡単）
javascriptfunction crossTrack(p){
  if(!A||!B)return null;
  const n = getRotatedDirN();
  const w = {x:p.x-A.xy.x, y:p.y-A.xy.y};
  // 符号を反転
  const perp = -(w.x*(-n.y) + w.y*(n.x));  // ← マイナスを追加
  return {perp}
}
方法2: 表示部分で修正
javascript// 表示の左右を入れ替える
el.dir.textContent = offset>0 ? '右へ →' : (offset<0 ? '← 左へ' : '—');
方法3: offset計算で修正
javascript// onGeo内で
const offset = -((currentLineIndex*swathWidth)-(ct?ct.perp:0));  // 符号反転
なぜこの問題が起きたか
座標系の認識違い：
一般的な期待：
- 右に移動 → 正の値 → "右へ"表示
- 左に移動 → 負の値 → "左へ"表示

現在のコード：
- 右に移動 → 負の値 → 正に変換 → "左へ"表示（逆！）
推奨する修正（最もシンプル）
javascript// app.js の crossTrack関数を修正
function crossTrack(p){
  if(!A||!B)return null;
  const n = getRotatedDirN();
  const w = {x:p.x-A.xy.x, y:p.y-A.xy.y};
  // 外積の符号を反転して、右が正、左が負になるように
  const perp = w.x*(n.y) + w.y*(-n.x);  // 符号を調整
  return {perp}
}
テスト方法

ABラインを南北方向に設定
ラインの東（右）に移動 → 「右へ →」と表示されるか確認
ラインの西（左）に移動 → 「← 左へ」と表示されるか確認

ビジュアル確認
javascript// drawViz関数も確認
const tx = Math.round(cx - offset*m2px);  // ← ここも要確認
// offsetが正の時、バーは左に表示される（逆かも）
もし視覚的にもバーの位置が逆なら：
javascriptconst tx = Math.round(cx + offset*m2px);  // 符号を反転
結論
クロストラック距離の計算で左右の符号が逆になっています。外積の計算を修正することで、実際の動きと表示が一致するようになります。